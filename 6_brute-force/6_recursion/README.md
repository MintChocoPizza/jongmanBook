# 재귀 함수(recursive function), 재귀 호출(recursion)
* 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수

## 코드 6.1
* 자연수 n이 주어졌을 때 1부터 n까지의 합을 반환하는 함수 sum()의 구현
* n개의 숫자의 합을 구하는 작업을 n개의 조각으로 쪼개, 더할 각 숫자가 하나의 조각이 되도록 함.
* 재귀 호출을 이용하기 위해서는 이 조각 중 하나를 떼내어 자신이 해결하고, 나머지 조각들은 자기 자신을 호출해 해결해야 함.
* 이 조각 중에서 n만 따로 빼내기로 함, 그러면 1 부터 n-1까지의 조각들이 남는데, 이들을 모두 처리한 결과는 다름아닌 __1부터 n-1까지의 합__이다.
* 따라서 자기 자신을 호출해 n-1가지의 합을 구한 뒤, 여기에 n을 더하면 원하는 답이 나옴.
### 주의
* n개의 조각 중 n이 아니라 1을 빼냈을 경우 이런 방법으로 문제를 해결할 수 없음.
* 1을 빼고 나면 2부터 n까지의 합이 남는데, 이것은 1부터 n까지의 합을 구한다는 원래 문제와는 다른 형태이다.
* 따라서 sum()을 호출해 계산할 수 없다.

``` C++
int sum(int n) {
    int ret = 0;
    for(int i=1; i<=n; ++i) 
        ret += i;
    return ret;
}

// 필수 조건: n >= 1
// 결과: 1부터 n까지의 합을 반환한다.
int recursiveSum(int n) {
    if(n == 1) return 1;    // 더이상 쪼개지지 않을 때
    return n + recursiveSum(n-1);
}
```
#### 기저 사례(base case)
* recursiveSum() 함수의 첫 줄에 있는 if문이 없다면, 함수가 제대로 동작하지 않는다.
* n=1이면 조각이 하나뿐이니, 한 개를 빼고 나면 더이상 처리할 작업이 없기 때문.
* __모든 재귀 함수는 이와 같이 '더이상 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야한다.__
* 이때 쪼개지지 않는 가장 작은 작업들을 가리켜 재귀 호출의 __기저 사례(base case)__라고 한다.
* 기저 사례를 선택할 때는 존재하는 모든 입력이 항상 기저 사례의 답을 이용해 계산될 수 있도록 신경써야 한다.


## 코드 6.2

``` C++
void pick(int n, vector<int>& picked, int toPick) {
    // 기저 사례: 더 고를 원소가 없을 때 고른 원소들을 출력한다.
    if(toPick == 0) { printPicked(picked); return ; }
    // 고를 수 있는 가장 작은 번호를 계산한다.
    int smalest = picked.empty() ? 0 : picked.back() + 1;
    // 이 단계에서 원소 하나를 고른다.
    for(int next=smalest; next < n; ++next) {
        picked.push_back(next);
        pick(n, picked, toPick-1);
        picked.pop_back();
    }
}
```

