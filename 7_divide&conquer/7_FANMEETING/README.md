## 무식하게 풀기
* 이 문제를 푸는 가장 단순한 방법은 문제에 나와 있는 과정대로 단순히 팬미팅 과정을 하나하나 시뮬레이션 하는 것 이다.
* 팬의 수를 $N$, 멤버의 수를 $M$이라고 할 때 이 방법은 대략 $O(NM - M^2)$에 해당하는 시간을 필요로 하는데 시간 안에 풀기 어렵다.

## 곱셈으로 변형
* 이 문제를 빠르게 푸는 방법은 놀랍게도 두 큰 수의 곱셈으로 이 문제를 바꾸는 것이다.
* 이것을 확인하기 위해 길이 $N$인 정수와 길이 $M$인 정수의 곱하는 과정을 살펴보면 된다.
* [코드 7.3][1]을 통해 길이가 3인 정수 $A$와 길이 6인 정수 $B$의 곱 $C$를 어떻게 계산하는지를 확인해보자.
* $multiply()$는 각 자릿수들의 곱들을 모두 계산하고,  각 세로줄의 합 $C_i$를 먼저 구한 뒤 올림 처리를 해서 곱셈을 완료한다.
* 그런데 여기서 $C_2, C_3, C_4, C_5$를 구하기 위해 더하는 값들이 다음 형태를 띠고 있다.
    
    $C_i = A_0 \cdot B_i + A_1 \cdot B_{i-1} + A_2 \cdot B_{i-2}$

* 이 형태는 이용할 수 있다.
* $A$의 원소들을 $B$의 연속된 원소들과 각각 곱한 후 그들의 합을 얻은 것 이다.
* 물론 $A$의 원소들과 $B$의 원소들이 서로 순서가 바뀌어 있다는 문제가 있지만, 그건 $A$의 원소들의 앞뒤를 뒤집은 다음 곱셈을 하면 문제가 없다. 그럼 다음과 같은 형태가 된다.


    제일 왼쪽의 멤버$(A_0)$가 제일 앞 순번의 팬$(B_{i-2})$와 팬미팅을 해야 한다.
    
    제일 오른쪽의 멤버$(A_2)$가 제일 뒤 순번의 팬$(B_i)$와 팬미팅을 해야 한다. 

    $C_i = A_2 \cdot B_i + A_1 \cdot B_{i-1} + A_0 \cdot B_{i-2}$

* 이제 $A$의 숫자들을 왼쪽으로 한 칸씩 움직이면서 $B$의 해당하는 숫자와 곱한 결과를 얻을 수 있다.
* 이 점을 깨닫고 나면 곱셈으로 이 문제를 해결하는 것은 쉽다.
    1. 일렬로 선 사람들의 성별을 긴 정수로 표시한다.
    2. 각 자릿수는 한 사람의 성별을 나타내며, 남성은 $1$, 여성은 $0$으로 표시한다.
    3. 그러면 남성과 남성이 만났을 때 두 자릿수의 곱은 1이 된다. 이 외의 경우에는 두 자릿수의 곱이 항상 0이 됨을 알 수 있다.
    4. 따라서 자리 올림을 생략했을 때(10진수가 아니라 21억진수를 다루고 있다고 생각하면 편하다) $C_i$가 $0$이라면 해당 위치에서 남성 팬과 남성 멤버가 만나는 일이 없고, 따라서 모든 멤버가 포옹을 한다는 것을 알 수 있다.

## 코드7.9
### 카라츠바 알고리즘을 이용한 구현
```C++
int hugs(const string& members, const string& fans) {
    int N = members.size(), M = fans.size();
    vector<int> A(N), B(M);
    for(int i=0; i<N; ++i) A[i] = (members[i] == 'M');
    for(int i=0; i<M; ++i) B[M-i-1] = (fans[i] == 'M');
    // karatsuba 알고리즘에서 자리 올림은 생략한다.
    vector<int> C = karatsuba(A, B);
    int allHugs = 0;
    for(int i=N-1; i<M; ++i)
        if(C[i] == 0)
            ++allHugs;
    return allHugs;
}
```


[1]: https://github.com/MintChocoPizza/jongmanBook/blob/master/7/7_Karatsuba/7_3.cpp