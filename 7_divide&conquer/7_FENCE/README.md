## 무식하게 풀기
* 각 판자의 높이의 배열 $h[]$가 주어졌을 때 $l$번 판자부터 $r$번 판자까지 잘라내서 사각형을 만든다고 할때, 이때 사각형의넓이는 다음과 같다.

    $(r-l+1) \times \underset{i=l} {\overset{r} \min h[i]}$

* 이때 문제를 풀 수 있는 가장 간단한 방법은 2중 for문으로 가능한 모든 $l$과 $r$을 순회하며 위 값을 계산하는 것이다.
### 코드 7.7
```C++
// 판자의 높이를 담은 배열 h[]가 주어질 때 사각형의 최대 너비를 반환한다.
int bruteForce(const vector<int>& h) {
    int ret = 0;
    int N = h.size();
    // 가능한 모든 left, right 조합을 순회한다.
    for(int left = 0; left < N; ++left) {
        int minHeight = h[left];
        for(int right = left; right < N; ++right) {
            minHeight = min(minHeight, h[right]);
            ret = max(ret, (right-left + 1) * minHeight);
        }
    }
    return ret;
}
```

## 분할 정복 알고리즘의 설계
* 분할 정복 알고리즘을 설계하기 위해서는 문제를 어떻게 분할할지 가장 먼저 결정해야한다.
* $n$개의 판자를 절반으로 나눠 두 개의 부분 문제를 만든다. 그러면 괴대 직사각형은 다음 세 가지 중 하나에 속한다.

    * 가장 큰 직사각형을 왼쪽 부분 문제에서만 잘라낼 수 있다.
    * 가장 큰 직사각형을 오른쪽 부분 문제에서만 잘라낼 수 있다.
    * 가장 큰 직사각형을 왼쪽 부분 문제와 오른쪽 부분 문제에 걸쳐 있다.

* 이때 첫 번째와 두 번째 경우는 반으로 나눈 부분 문제를 재귀 호출하여 해결할 수 있다.

### 양쪽 부분 문제에 걸친 경우의 답
* 양쪽 부분 문제에 모두 걸치는 직사각형 중 가장 큰 것을 어떻게 찾을 수 있을까? 힌트는 이 직사각형은 반드시 부분 문제 경계에 있는 두 판자를 포함한다는 데 있다.
* 정답은 더 높은 판자를 포함하게끔 확장하는 것이다.
* 가장 큰 사각형을 찾으려면 항상 사각형의 높이를 최대화하는 방향으로 확장해야 한다.

## 코드 7.8
```C++
// 각 판자의 높이를 저장하는 배열
vector<int> h;
// h[left..right] 구간에서 찾아낼 수 있는 가장 큰 사각형의 넓이를 반환한다.
int solve(int left, int right) {
    // 기저 사례: 판자가 하나밖에 없는 경우
    if(left == right) return h[left];
    // [left, mid], [mid + 1, right]의 두 구간으로 문제를 분할한다.
    int mid = (left + right) / 2;
    // 분할한 문제를 각개격파
    int ret = max(solve(left, mid), solve(mid+1, right));

    // 부분 문제 3: 두 부분에 모두 걸치는 사각형 중 가장 큰 것을 찾는다.
    int lo = mid, hi = mid+1;
    int height = min(h[lo], h[hi]);
    // [mid, mid + 1]만 포함하는 너비 2인 사각형을 고려한다.
    ret = max(ret, height * 2);
    // 사각형이 입력 전체를 덮을 때까지 확장해 나간다.
    while(left < lo || hi < right) {
        // 항상 높이가 더 높은 쪽으로 확장한다.
        // hi가 범위를 벗어나지 않고, hi의 높이가 더 높을 때
        if(hi < right && (lo == left || h[lo-1] < h[hi+1])) {
            ++hi;
            height = min(height, h[hi]);
        }
        // !(hi < right && (lo == left || h[lo-1] < h[hi+1]))
        // (!(hi < right) || !(lo == left || h[lo-1] < h[hi+1] ))
        // ((hi >= right) || (lo != left && h[lo-1] >= h[hi+1] ))
        else {
            -- lo;
            height = min(height, h[lo]);
        }
        // 확장한 후 사각형의 넓이
        ret = max(ret, height * (hi - lo + 1));
    }
    return ret;
}
```

### 정당성 증명 
* 이 알고리즘의 정당성을 보이려 할 때 핵심이 되는 부분은 양쪽 부분 문제에 걸쳐 있는 직사각형을 찾을 때, 각 단계마다 더 높은 판자를 택하는 것이 항상 옳음을 보이는 부분이다.
* 이것은 귀류법을 이용해 쉽게 증명할 수 있다.
* 가정: 어떤 사각형 $R$이 우리가 이 과정을 통해 찾은 최대 직사각형보다 더 크다고 가정한다.
* 우리는 너비가 2인 사각형에서 시작해서 한 칸씩 사각형의 너비를 늘려가므로, 우리가 고려한 사각형들 중 $R$과 너비가 같은 사각형이 반드시 하나 있다. 이 사각형을 $R'$라고 한다.
* 너비가 같으므로 $R$이 더 넓기 위해서는 높이가 반드시 $R'$보다 높아야 한다.
* $R$과 $R'$은 둘 다 부분 문제 경계에 있는 두 개의 판자를 포함하므로 항상 겹치는 부분이 있다.
* 이때 $R'$의 높이를 결정하는 가장 낮은 판자$A$에 주목해야 한다.
* $R$이 $R'$보다 높으니, $R$에 포함된 모든 판자들은 당연히 $A$보다 높아야 한다.
* 그렇다면 우리의 알고리즘은 대체 언제 $A$를 선택했을까?
* 우리의 알고리즘은 현재 사각형의 양쪽 끝에 있는 두 판자 중 항상 더 높은 것을 선택하므로, $A$보다 낮거나 높이가 같은 판자를 만나야만 $A$를 선택하게 된다.
* 그런데 $R'$을 만드는 과정에서 만나는 반대쪽 판자들은 모두 $R$에 속해 있으므로 $A$보다 높다.
* 따라서 $A$를 선택하는 경우가 있을 수 없으며, $R$이 $R'$보다 높다는 우리의 가정이 모순이라는 사실을 알게 된다.
* 이렇게 코드 $7.8$에서 고려하는 사각형 중에 반드시 최대 사각형이 있다는 것을 증명할 수 있다.
----
* 코드 $7.8$이 가운데 있는 두 개의 판자에서 시작해 $R'$을 찾아냈다면 중간에 반드시 언젠가 판자 $A$와 $B$의 높이를 비교해야만 한다.
* 이때 우리가 판자 $B$를 선택했다는 말은 판자 $B$가 $A$보다 낮을 리 없다는 뜻이다. 따라서 $R$은 $B$보다 높을 수 없고, 이것은 애초에 우리가 했던 가정에 모순이기 때문에 $R'R보다 넓은 $R$은 존재하지 않는다.
* 이와 같이 귀류법으로 코드 $7.8$에서 고려하는 사각형 중에 반드시 최대 사각형이 있다는 사실을 알 수 있다.