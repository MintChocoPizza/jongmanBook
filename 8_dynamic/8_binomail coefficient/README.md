# 이항 계수(binomial coefficient)
* 동적 계획법 알고리즘의 가장 유명한 예 중 하나는 이항 계수의 계산이다.
* 이항 계수 ${n \choose r}$은 $n$개의 서로 다른 원소 중에서 $r$개의 원소를 순서없이 골라내는 방법의 수를 나타내는 것으로, 이항 계수에는 다음과 같은 점화식이 성립힌다.

    ${n \choose r} = {n-1 \choose r-1} + {n-1 \choose r}$

* 이 점화식을 이용하면 $n, r$의 값이 주어질 때 ${n \choose r}$의 값을 반환하는 함수 $bino(n, r)$를 작성할 수 있다. 
* $bino(n, r)$의 수행 시간은 재귀 호출이 몇 번이나 이루어지는지를 계산하면 파악할 수 있다.
* 이때 주목할 점은 이항 계수의 특성상 같은 값을 두 번 이상 계산할 일이 빈번하다는 것이다.

## 코드 8.1 재귀 호출을 이용한 이항 계수의 계산
```C++
int bino(int n, int r) {
    // 기저 사례: n=r(모든 원소를 다 고르는 경우) 혹은 r=0 (고를 원소가 없는 경우)
    if(r == 0 || n == r) return 1;
    return bino(n-1, r-1) + bino(n-1, r);
}
```
* bino(4, 2)를 계산하는 과정의 함수 호출을 그려보면 bino(2, 1)이 두 번 호출된다.
* 함수의 중복 호출 수는 $n$과 $r$이 커짐에 따라 기하급수적으로 증가한다.
* $bino(n, \left[ \frac{n}{2} \right])$를 계산하기 위해 필요한 함수 호출의 수를 아래의 표[here](#my-table)와 같이 계산해 보면, $n$이 하나 증가할 때마다 함수 호출의 수가 거의 두 배 증가하는 것을 볼 수 있다.


<div id="my-table"></div>

n                      | 2 | 3 | 4 | 5 | 6 | $\cdots$  | 18    | 19     | $\cdots$ | 24      | 25
-----------------------|---|---|---|---|---|-----------|-------|--------|----------|---------|-------
  $bino()$ 호출 횟수     | 3 | 5 | 11| 19| 39| $\cdots$  | 97239 | 184755 | $\cdots$ | 5408311 | 10400599
  $bino2()$ 호출 횟수    | 3 | 5 | 8 | 11| 15| $\cdots$  | 99    | 109    | $\cdots$ | 168     | 181


* 입력인 $n$과 $r$이 정해져 있을 때 $bino(n, r)$의 반환 값이 일정하다는 사실을 이용하면 이 문제에서 중복 계산을 제거할 수 있다.
* 각 $n, r$조합에 대해 답을 저장하는 캐시 배열을 만들어서 각 입력에 대한 반환 값을 저장하기로 한다.
* 함수는 매번 호출될 때마다 이 배열에 접근해 값이 저장되어 있는지를 확인한 뒤, 저장되어 있다면 이것을 즉시 반환한다.

* 만약 계산되어 있지 않을 경우엔 직접 계산하여 배열에 써넣고 반환한다.

## 코드 8.2
```C++
// -1로 초기화해 둔다.
int cache[30][30];
int bino2(int n, int r) {
    // 기저 사례: 
    if(r == 0 || n == r) return 1;
    // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
    if(cache[n][r] != -1)
        return cache[n][r];
    // 직접 계산한 뒤 배열에 저장
    return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
}
```
* 이와 같이 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산 한 값을 저장해 뒀다 재활용하는 최적화 기법을 __메모이제이션(memoization)__ 이라고 부른다.
* 메모이제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장할 수 있기 때문에 함수 호출 횟수가 엄청나게 감소하리라 예상할 수 있다.
* 위의 표[here](#my-table)를 보면 $n$이 1 증가할 때마다 두 배씩 증가하던 $bino()$의 호출 횟수가 $bino2()$에서는 $n$의 제곱꼴로 증가하게 된다.
    
    ### 이와 같이 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법을 동적 계획법이라고 한다.