# 메모이제이션을 적용할 수 있는 경우
* 프로그래밍을 처음 배울 때 혼란스러운 점 중 하나는, 수학의 함수와 프로그래밍에서의 함수가 비슷해 보이지만 사실 다르다는 것이다.

* 수학의 함수에서는, 입력이 정해져 있을 때 출력도 언제나 정해져 있다. 
    
    예를 들어 $sin(\pi)$는 몇 번을 계산하건 항상 0이다. 
    $f(x)=\frac{x}{2}$라고 하면 $f(10)$은 언제나 5이다.

* 그러나 프로그래밍을 할 때는 이러한 속성이 성립하지 않는다.
* 프로그래밍에서의 함수는 함수의 입력 외에도 전역 변수, 입력 파일, 클래스의 멤버 변수 등 수많은 입력에 의해 작동하기 때문이다. 아래와 같은 함수를 예로 들어보자.
```C++
int counter = 0;
int count() {
    return counter++;
}
```
* 이 함수는 입력을 전혀 받지 않으면서도 매번 다른 결과를 반환한다.

* 반면 입력이 같으면 출력도 항상 같은 함수도 작성할 수 있다.
 앞에서 봤던 $bino()$나 $bino2()$가 이의 좋은 예이다.

 * 함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 유식한 말로 __참조적 투명성(referential transparency)__ 이라고 부른다.

 * __당연하게도 메모이제이션은 참조적 투명 함수의 경우에만 적용할 수 있다.__ 입력이 같은데도 외부 요소에 따라 다른 값이 반환된다면 캐싱을 할 수가 없다.

 ## 메모이제이션 구현 패턴
 * 동적 계획법은 가장 흔한 문제 유형 중 하나이기 때문에 메모이제이션은 굉장히 자주 구현하게 된다.

 *    ## 그런 만큼 한 가지 패턴을 정해두고 항상 같은 형태로 구현하기로 하면 작성하기도, 버그를 찾기도 쉬워진다.

 ```C++
 // a와 b는 각각 [0, 2500) 구간 안의 정수
 // 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
 int someObscureFunction(int a, int b);
 ```
  $someObscureFunction()$은 한 번 계산하는 데 굉장히 시간이 오래 걸리는 __참조적 투명 함수__ 라고 가정한다.

  * 코드 8.3은 어떻게 이 함수를 메모이제이션으로 바꿔 구현하는지를 보인다. 아래와 같은 점을 유의해서 보자.


    * 항상 기저 사례를 제일 먼저 처리한다. 입력이 범위를 벗어난 경우 등을 기저 사례로 처리하면 매우 유용한데, 기저 사례를 먼저 확인하지 않고 cache[]에 접근하면 범위를 벗어나는 등의 오류가 있을 수 있다.
    * 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 모두 -1로 초기화했다. $cache[]$의 해당 위치에 적혀 있는 값이 -1이라면 이 값은 계산된 반환 값일리 없다. 만약 함수의 반환 값이 음수일 수도 있다면 이 방법은 써먹을 수 없을 것이다.
    * $ret$가 $cache[a][b]$에 대한 참조형(reference)이라는데 유의하자. 참조형 $ret$의 값을 바꾸면 $cache[a][b]$의 값도 변하기 때문에 답을 저장할 때도 매번 귀찮게 $cache[a][b]$라고 쓸 필요가 없어진다. 이 트릭은 특히 $cache$가 다차원 배열일 때 유용하다. 귀찮기는 둘째 치고 인덱스 순서를 바꿔 쓴다거나 하는 실수를 할 가능성을 없애 준다.
    * 또 하나 눈여겨볼 것은 $memset()을 이용해 $cache[]$를 초기화하는 부분이다. 메모이제이션용 배열을 초기화하는 것은 매우 자주 하는 일이기 때문에 다중 for문보다 쉽게 초기화할 수 있는 방법을 알아 두면 간편하다. 단 $memset()$으로 배열을 초기화하는 방법은 굉장히 제한적인 경우에만 쓸 수 있는 일이니 유의해야한다.[here](#memset)

## 코드 8.3
```C++
// 전부 -1로 초기화해 둔다
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int somObscureFunction(int a, int b); {
    // 기저 사례를 처음에 처리한다
    if(...) return ...;
    // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
    int& ret = cache[a][b];
    if(ret != -1) return ret;
    // 여기에서 답을 계산한다.
    ...
    return ret;
}
int main() {
    // memset()을 이용해 cache 배열을 초기화 한다.
    memset(cache, -1, sizeof(cache));
}
```
* 모든 메모이제이션 코드들은 이 패턴을 따라 구성되어 있다.
* 이 패턴을 그대로 따를 필요는 없지만, 자신이 가장 좋다고 생각하는 방식을 하나 정해 일관되게 사용하는 것이 좋다.



<div id="memset"></div>
* memset()은 두 번째 인자로 주어진 값을 주어진 메모리의 모든 바이트에 채웁니다. 만약 배열이 32비트나 64비트 정수형이라면, 각 바이트마다 값이 들어가기 때문에 엉뚱한 수로 초기화될 수 있습니다. memset()으로 정수 배열에 0 혹은 -1을 채울 수 있는 이유는 각 바이트에 해당 숫자를 집어넣고 부호 있는 정수형으로 해석하면 '운 좋게도' 해당 숫자와 같아지기 때문입니다.
