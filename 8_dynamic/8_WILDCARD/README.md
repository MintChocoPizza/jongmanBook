# 8.2 문제: 와일드카드 (문제 ID: WILDCARD, 난이도: 중)

## *가 문제다
* 이 문제가 어려운 이유는 *가 몇 글자에 대응되어야 하는지를 미리 알 수 없다는 점이다.
* 이럴때 할 수 있는 가장 쉬운 방법은 역시 완전탐색이다.
* 주어진 패턴이 $m$개의 $*$를 포함한다고 하자.
* 이 패턴을 $*$가 나타날 때마다 쪼개면 이 패턴이 문자열에 대응되는지 확인하는 문제를 $m+1$조각으로 나눌 수 있다.
* 예를 들어 패턴 $t*l?*o*r?ng*s$는 $\left\{ t*, l?*, o*, r?ng*, s \right\}$의 다섯 조각으로 쪼개진다.
* 문자열 $thelordoftherings$가 주어질 때 우리의 완전 탐색 함수는 이 문자열 중 모두 몇 글자가 첫 번째 조각에 대응될지를 찾아내기 위해 모든 경우의 수를 다 시도해 본다.

* 만약 첫 번째 조각에 세 글자가 대응된다고 하면, 나머지 문자열 $lordoftherings$가 
나머지 네 개의 패턴 조각들에 대응되는지 여부를 재귀 호출로 파악할 수 있다.

* 물론 실제로 패턴을 직접 쪼개지 않고도 이를 구현할 수 있다.

* 와일드카드 $w$가 원문 $s$에 대응되는지 여부를 반환하는 함수 $match(w, s)$를 만들어 보자.

* $w$와 $s$를 앞에서부터 한 글자씩 대응해 나가며, $*$를 만나거나 둘 중 한 문자열이 끝날 때에 멈춘다.
```C++
// 와일드카트 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(const string& w, const string& s) {
    // w[pos]와 s[pos]를 맞춰나간다.
    int pos = 0;
    while(pos < s.size() && pos < w.size() && (w[pos] == '?' || w[pos] == s[pos]))
    ++ pos;
    ...
}
```
* while문은 w와 s를 더이상 맞춰 나갈 수 없을 때 종료한다. 종료하는 경우의 수를 좁더 자세히 따져 봐야한다.
    1. $s[pos]$와 $w[pos]$가 대응되지 않는다: 볼 것도 없이 대응 실패라는 것을 알 수 있다.
    2. $w$ 끝에 도달했다: 패턴에 $*$이 하나도 없는 경우다. 이 경우에 패턴과 문자열의 길이가 정확히 같아야만 패턴과 문자열이 대응된다고 할 수 있다.
    3. $s$끝에 도달했다: 패턴은 남아있지만 문자열이 이미 끝난 경우이다. 당연히 대응 실패라고 생각할 수 있지만, 남은 패턴이 전부 $*$로 구성되어 있다면 사실 두 문자열은 대응될 수 있다.
    4. $w[pos]$가 $*$인 경우: $*$가 몇 글자에 대응될지 모르기 때문에, 0 글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사해야한다. 이때 $w$의 $pos + 1$이후를 패턴 $w'$으로 하고, $s$의 $pos+skip$이후를 문자열 $s'$로 해서 $match(w', s')$로 재귀 호출을 했을 때 답이 하나라도 참이면 답은 참이 도니다.


## 코드 8.6
* 3번의 경우에서 남은 패턴이 모두 $*$인 경우의 예외를 따로 처리하지 않은 점을 눈여겨봐야한다.
* 이 경우는 4번을 처리할 때 재귀 호출되기 때문에 별도로 처리할 필요가 없다.
* 별도의 기저 사례가 필요없다는 점도 눈여겨보자.
```C++
// 와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(const string& w, const string& s) {
    // w[pos]와 s[pos]를 맞춰나간다.
    int pos = 0;
    while(pos < s.size() && pos < w.size() && (w[pos] == '?' || w[pos] == s[pos]))
        ++pos;
    // 더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
    // 2. 패턴이 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨
    if(pos == w.size())
        return pos == s.size();
    // 4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
    if(w[pos] == '*')
        for(int skip = 0; pos+skip <= s.size(); ++skip)
            if(match(w.substr(pos+1), s.substr(pos+skip)))
                return true;
    // 이 외의 경우에는 모든 대응되지 않는다.
    return false;
}
```

## 중복되는 부분 문제
* 위의 알고리즘은 일부 예제 입력의 경우에는 너무 오랜 시간이 걸리 수 있다는 문제가 있다.
* 완전 탐색은 각 $*$에 대응되는 글자 수의 모든 조합을 검사하는데, 문자열이 길고 $*$가 많을 수록 이 경우의 수는 늘어난다.
* 만약 이 코드가 실행되는 과정에서 수행하는 계산의 대부분이 여러번 중복으로 이루어진다면, 입력이 주어졌을 때 답을 저장하는 캐시를 이용하여 프로그램을 훨씬 빠르게 할 수 있다.

* 그런데 과연 중복 계산이 얼마나 일어날까? 중요한 단서는 입력으로 주어질 수 있는 $w$와 $s$의 종류는 제한되어 있다는 것이다. 
* 재귀 호출할 때 항상 $w$와 $s$의 앞에서만 글자들을 떼내기 때문에 $w$와 $s$는 항상 입력으로 주어진 패턴 $W$와 파일명 $S$의 접미사(suffix)[here](#my-suffix)가 된다.
* 따라서 입력으로 주어질 수 있는 $w$와 $s$는 각각 최대 101개밖에 없다. (문자열의 길이는 각각 쵀대 100 이다.)

*  이때 $match()$가 $101 \times 101 = 10201$번 이상 호출되었다면 비둘기집의 원리에 따라 어떤 부분 문제가 반드시 여러 번 계산되고 있다는 뜻이다.

* 메모이제이션을 사용해 이 상황을 해결해 보자. $w$는 항상 전체 패턴 $W$의 접미사이기 때문에 $w$의 길이가 결정되면 $w$또한 결정된다.
* 이 점을 이용하면 $101 \times 101$ 크기의 배열에 모든 부분 문제의 답을 저장할 수 있다.

## 코드 8.7
* 코드 8.7은 메모이제이션을 이용해 같은 알고리즘을 구현한다.
* 더이상 문자열을 재귀 호출의 인자로 넘기지 않고, 두 문자열의 시작 위치만을 넘기는 것을 눈여겨보자.
* 이렇게 함으로써 매번 문자열 객체를 생성하는 수고를 덜 수 있다.
* 코드 8.6과 비교해보면, 입력을 정수형으로 바꾸고 메모이제이션을 적용했을 뿐, 둘은 본질적으로 완전히 같은 알고리즘이다.
```C++
// -1은 아직 답이 계산되지 않았음을 의미한다. -> 기본적인 초깃값
// 1은 해당 입력들이 서로 대응됨을 의미한다.
// 0은 해당 입력들이 서로 대응되지 않음을 의미한다.
int cache[101][101];
// 패턴과 문자열 
string W, S;
// 와일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환한다.
bool matchMemoized(int w, int s) {
    // 메모이제이션
    int& ret = cache[w][s];
    if(ret != -1) return ret;
    // W[w]와 S[s]를 맞춰나간다.
    while(s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
        ++w;
        ++s;
    }
    // 더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
    // 2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 참
    if(w == W.size()) return ret = (s == S.size());
    // 4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
    if(W[w] == '*')
        for(int skip = 0; skip+s <= S.size(); ++skip)
            if(matchMemoized(w+1, s+skip))
                return ret = 1;
    // 3. 이 외의 경우에는 모두 대응되지 않는다.
    return ret = 0;
}
```
* 패턴과 문자열의 길이가 모두 $n$이라고 할 때, 부분 문제의 개수는 $n^2$이다.
* $matchMemoized()$는 한 번 호출될 때마다 최대 $n$번의 재귀 호출을 하기 때문에 전체 시간 복잡도는 $O(n^3)$이다. 
* $n \leqq 100$이면 충분히 시간 안에 해결할 수 있다.

### 다른 분해 방법
* 사실 좀더 똑똑한 분해 방식을 쓰면 이 문제를 $O(n^2)$시간에 풀 수 있다.
* 코드 8.7이 $O(n^3)$시간이 걸리는 것은 내부에서 첫 $*$를 찾고, $*$에 몇 글자가 대응되어야 할지 검사하는 반복문이 존재하기 때문이다.
* 만약 재귀 함수 자체에 반복문이 하나도 없도록 코드를 바꿀 수 있다면 부분 문제 개수와 같은 시간만을 사용해 문제를 풀 수 있을 것이다.

    * 우선 첫 번째 $*$를 찾는 반복문을 보자.
    ```C++
    // W[w]와 S[s]를 맞춰나간다.
    while(s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
        ++w;
        ++s;
    }
    ```
* while문의 조건을 통과했다는 것은 두 글자 $W[w]$와 $S[s]$가 서로 대응된다는 의미이다.
* 이때 $w$와 $s$를 $1$씩 증가하고 계속하는 대신에 패턴과 문자열의 첫 한 글자씩을 떼고 이들이 서로 대응되는지를 재귀 호출로 확인할 수 있다.
    ```C++
    if(w < W.size() && s < S.size() && (W[w] == '?' || W[w] == S[s]))
    return ret = matchMemoized(w+1, s+1);
    ```
* 다음으로는 $*$에 몇 글자가 대응되어야 할지를 확인하는 반복문을 재귀 호출로 바꿔보자.
* $1$차원 for문을 재귀 호출로 바꾸는 것은 간단하다.
* 매 단계에서 $*$에 아무 글자도 대응시키지 않을 것인지, 아니면 한 글자를 더 대응시킬 것인가를 결정하면 된다.
    ```C++
    // 4. *를 만나서 끝난 경우: *에 몇글자를 대응해야 할지 재귀 호출하면서 확인한다.
    if(W[w] == '*') {
        if(matchMemoized(w+1, s) || (s < S.size() && matchMemoized(w, s+1)))
            return ret = 1;
    }
    ```
* 이렇게 하면 0글자 대응되는 경우, 한 글자 대응되는 경우 등을 모두 재귀 호출을 통해 확인하고 그 과정을 __메모이제이션으로 캐싱하게 된다.__
* 이와 같이 바꾸면 알고리즘의 시간 복잡도는 $O(n^2)$가 된다.

#### 기억 더듬기
* 위의 문제는 패턴 $w$가 문자열 $s$에 대응되는지 여부를 확인하는 함수이다. 그리고 재귀호출되어 또 $w'$가 $s'$에 대응되는지 확인한다.
* 결국 $w,s$는 $W,S$의 접미사[here](#my-suffix)로 $101 \times 101 = 10201$번 이상 호출되었다면 비둘기집의 원리에 따라 어떤 부분 문제가 반드시 여러 번 계산되고 있다는 뜻이다.
* $w,s$의 시작 위치를 확인하여 메모이제이션을 한다.
* $w$의 시작위치와 $s$의 시작위치가 같다면,  같은 패턴$w$와 같은 문자열$s$가 대응되는지 확인하므로 메모이제이션이 가능하다.




<div id="my-suffix"></div>
접미사는 문자열의 맨 앞에서 0글자 이상의 문자를 지운 부분 문자열을 의미한다. 예를 들어 man은 spiderman의 접미사이지만 mana는 아니다.

