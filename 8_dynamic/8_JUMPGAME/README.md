# 예제: 외발 뛰기(문제 ID: JUMPGAME, 난이도: 하)


### 재귀 호출에서 시작하기
* __동적 계획법 알고리즘을 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다.__

* 완전 탐색 알고리즘은 맨 왼쪽 윗 칸에서 시작하는 모든 경로를 하나씩 만들어 보면서 마지막 칸에 도달할 수 있는지를 검사한다.

* $jump(y, x) = (y, x)$에서부터 맨 마지막 칸까지 도달할 수 있는지 여부를 반환한다.

* $jump()$는 한 번 호출될 때마다 여기에서 아래쪽으로 뛸지, 오른쪽으로 뛸지를 선택하면 된다.

* 게임판의 $(y, x)$ 위치에 있는 수를 $jumpSize$라고 하면, 각 경우 아래쪽으로 뛸 경우 마지막 칸에 도달할 수 있는지를 $jump(y+jumpSize, x)$, 오른쪽으로 뛸 경우를 $jump(y, x+jumpSize)$로 표편할 수 있다.

* 이 두 경우 중 하나만 성공해도 상관 없으니 $jump(y, x)$는 다음과 같이 재귀적으로 표현할 수 있다.

    $jump(y+jumpSize, x) \ || \ jump(y, x+jumpSize)$

## 코드 8.5
```C++
int n, board[100][100];
bool jump(int y, int x) {
    // 기저 사례: 게임판 밖을 벗어난 경우
    if(y >= n || x >= n) return false;
    // 기저 사례: 마지막 칸에 도착한 경우
    if(y == n-1 && x == n-1) return true;
    int jumpSize = board[y][x];
    return jump(y+jumpSize, x) || jump(y, x+jumpSize);
}
```

### 메모제이션 적용하기
* "원하는 답이 존재하는가?"라는 질문을 완전 탐색으로 구할 때 흔히 가장 문제가 되는 것은, 원하는 답은 없는데 전체 답의 개수는 무지막지하게 많은 경우이다.

* 여기서 주목할 것은 완전 탐색이 만드는 경로의 수는 엄청나게 많지만 $jump()$에 주어지는 입력의 개수는 $100 \times 100 = 10,000$개뿐이라는 사실이다.

* 이 경우 비둘기집의 원리에 의해 중복으로 해결되는 부분 문제들이 항상 존재함을 알게 돤디.

* $jump()$는 참조적 투명 함수이기 때문에 메모이제이션을 적용해서 중복된 연산을 없앨 수 있다.

* $bool$값을 반환하던 $jump()$와 달리 $jump2()$는 정수를 반환한다는 점에 유의해야한다.

* 비록 $jump2()$가 반환하는 값은 참/ 거짓 둘 중의 하나이지만, $bool$값 배열을 캐시로 사용해서는 아직 계산되지 않은 상태인지 아닌지 알 수 있는 방법이 없기 때문이다.

* 1 또는 0의 정수를 반환하기로 약속하면 -1로 초기화한 정수형 배열을 캐시로 사용할 수 있다.

* 그러나 $jump()$와 $jump2()$는 메모이제이션을 적용한 부분 말고는 완전히 똑같다.

* 그 외에 $jump2()$가 앞에서 다뤘던 메모이제이션 패턴을 충실히 따르고 있다.

## 코드 8.5
```C++
int n, board[100][100];
int cache[100][100];
int jump2(int y, int x) {
    // 기저 사례 처리
    if(y >= n || x >= n) return 0;
    if(y == n-1 || x == n-1) return 1;
    // 메모이제이션
    int& ret = cache[y][x];
    if(ret != -1) return ret;
    int jumpSize = board[y][x];
    return ret = (jump2(y + jumpSize, x) || jump2(y, x + jumpSize));
}
```
* 대개 동적 계획법 알고리즘의 구현은 다음과 같은 두 단계로 이루어진다.
    1. 주어진 문제를 완전 탐색을 이용해 해결한다.
    2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

* 물론 이 설명은 대단히 단수화한 것이다.

### 다른 구현 방법에 관하여
* 물론 재귀 호출을 이용하지 않고도 동적 계획법 알고리즘을 구현할 수 있다.

* 이런 방법을 반복적 동적 계획법이라고 부른다.

* 반복적 동적 계획법에도 많은 장점이 있지만, 메모이제이션을 통한 접근이 좀더 직관적이기 때문에 기본적으로 모든 동적 계획법 알고리즘을 재귀호출을 통해 구현한다.
