# 8.9 문제: Quantization (문제 ID: QUANTIZE, 난이도: 중)

## 하던 대는 안  된다
* 지금까지의 연습 문제와는 달리 이 문는 주어진 그대로 재귀적인 해법을 찾으려고 하면 성공할 수 없다. 단순하게 생각해 보면 양자화된 결과 수열을 답으로 생각하고, 맨 앞의 숫자에서부터 하나씩 채워 나가는 접근 방법을 택하게 된다.
* 주어진 수열 $A$의 첫 번째 숫자를 어떤 숫자로 표현할 것인지를 결정하고, 나머지 수열에 대해 재귀 호출로 문제를 해결하는 식이다.

    $quantize(A) = A$에 속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합

* 그런데 이 문제에서는 사용할 수 있는 숫자의 가짓수에 제한이 있기 때문에 남은 문제를 재귀적으로 해결할 때는 이 함수처럼 지금가지 사용한 숫자들을 무시할 수 가 없다.
* 이미 $s$가지의 숫자를 다 쓴 상태라면 이 중 하나의 숫자를 선택해야 하기 때문이다. 
* 다시 말하면 최적 부분 조건이 성립하지 않는다.


* 이렇듯 $quantize()$는 남은 숫자들만이 아니라 이전 숫자들을 어떤 숫자로 양자화했는지 또한 알아야 하기 때문에, 지금까지 사용한 숫자들의 집합 또한 입력으로 받아야 한다. 결국 다음과 같은 형태의 함수를 구현하게 된다.

    $quantize(A, U) = U$가 지금까지 한 번 이상 사용한 숫자들의 집합일 때 $A$에 속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합

* 그러면 $quantize()$는 $A$의 첫 번째 숫자를 어떻게 표현할지를 결정하고 나머지를 재귀 호출해서 해결하게 된다.
* 그러나 이런 완전 탐색 코드는 실로 엄청나게 많은 수의 답을 하나하나 만들게 도니다. 
* 원본 수열에 포함된 수들의 범위가 $1,000$ 이하의 자연수이니, $U$의 크기가 $10$인 경우에만도 ${1000 \choose 10}$개의 부분 문제가 존재할 수 있다.
* 메모이제이션에 필요한 메모리를 확보할 수 없는 것은 물론 이고, 아마 인류 문명이 멸망할 때까지 답을 구할 수 없을 것이다.

## 답의 형태 제한하기
* 이와 같이 부분 문제의 개수가 너무 많을 때 우리가 시도할 수 있는 방법은 굉장히 많다. 그중 이 문제에 유용하게 쓰이는 방법은 답이 항상 어떤 구조를 가질 것이라고 예측하고 그것을 강제하는 것이다.
* 답이 갖는 구조를 예측한다고 해서 꼭 복잡한 것은 아니다.
* 예제 입력을 포함한 작은 입력 몇 개를 손을 손으로 풀어 보면, 두 숫자 $a < b$에 대해 $a$에 대응되는 숫자가 $b$에 대응되는 숫자보다 커서는 안 된다는 사실을 깨달을 수 있다.
* 예를 들어 $1$을 $7$로 바꿨는데, $9$를 $6$으로 바꾸는 것은 절대 최적해가 될 수 없다.
* 대응되는 두 숫자를 서로 바꾸면 항상 더 작은 오차를 얻을 수 있기 때문이다.
* 이것을 좀더 일반화하면 다음과 같이 주장할 수 있다.

        주어진 수열을 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있다!!!!

* 예를 들어 보면 좀더 당연하다. $\{ 1,2,3,4 \}$를 양자화하는데, 최적해가 $\{ 2,2,3,2 \}$와 같은 형태일 리는 없다.
* 이렇게 생각하면 이 문제를 해결하는 방법이 보인다. 우선 입력에 주어지는 수를 정렬한 뒤, 인접한 숫자끼리 묶음으로 적절히 분할하고, 각 묶음을 한 숫자로 표현해서 오류를 최소화하는 것이다.
* 오차 제곱의 합은 각 숫자의 순서가 변하더라도 상관 없기 때문에 이와 같이 풀 수 있다.

    $\begin{matrix} {\{ 1,4,6,744,755,777,890,897,902 \}}  \\ \downarrow \\ { \underbrace{ \{1,4,6\} }_{\text{4}}, \  \underbrace{ \{744, 755, 777 \}}_{\text{759}}, \ \underbrace{ \{ 890, 897, 902 \}}_{\text{896}} } \end{matrix}$

* 따라서 이 문제는 이제 주어진 수열을 $s$개의 묶음으로 나누는 문제가 된다.
* 이것은 비교적 쉽게 재귀적으로 해결할 수 있다. 매 재귀 호출 때마다, 첫 묶음의 크기가 얼마일지를 결정하면 된다.
* 첫 묶음의 크기를 $x$라고 한다면 이제 나머지 $n-x$개의 숫자를 $s-1$개의 묶음으로 나누면 된다.
* 이때 나머지 $s-1$ 묶음의 오류 합이 최소여야 전체도 최소 오류이기 때문에, 최적 부분 구조 또한 성립한다는 것을 알 수 있다.

* $from$번째 이후의 숫자들을 $parts$개의 묶음으로 묶을 때, 최소 오류 제곱 합을 반환하는 함수 $quantize(from, parts)$가 있다고 하자.
* $parts$개의 묶음 중 첫 번째의 크기는 $1$이상 $n-from$이하의 값이므로, 이들을 각각 다 계산해 보면 된다.
* 첫 번째 묶음의 크기가 $size$일 때의 최소 오류는 $minError(from, from+size-1)+quantize(from+size, parts-1)$이 된다.
* $(minError(a,b)$는 $a$번째 숫자부터 $b$번째 숫자까지를 하나의 수로 표현했을 때의 최소 오류를 반환한다고 합시다.)
* 따라서 다음과 같은 점화식이 성립한다.

    $quantize(from, parts) = \underset{size=1}{\overset{n-from}{min}} [minError(from, from+size-1) + quantize(from + size, parts-1)]$

* 이 점화식을 구현하면 동적 계획법 알고리즘을 얻을 수 있다. 
* $quantize()$가 이전 묶음들에 대한 정보를 전혀 입력받지 않는다는 것을 눈여겨보자.
* 남은 숫자들읠 최적으로 묶는 데 이전 조각의 정보는 필요가 없다.
* 이것은 이 문제에서도 최적 부분 조건이 성립함을 나타낸다.

## 한 개의 구간에 대한 답 찾기
* 위에서 언급한 $minError()$를 실제로 구현하기 하려면 $minError(a, b)$에서 해야 하는 일은 크게 두 가지이다.
        
        1. 주어진 구간을 어떤 수로 표현해야 할지 결정하기
        2. 결정한 수 m으로 해당 구간을 표현했을 때 오차를 계산하기

* 이 문제의 시간 제한은 이들을 가능한 한 간단한 방법을 이용해 풀더라도 문제를 해결할 수 있게끔 조정되어 있지만, 여기에서는 참고 삼아 다른 방법들 또한 이야기 해보겠다.
* 우선 해당 구간을 표현할 숫자를 결정하는 방법들에 대해 생각해보자.
* 무식하게 풀 수 있을까?라는 질문에 가장 적절하게 대답한 예는, 바로 가능한 모든 숫자를 다 시도해 본다는 것이다.
* 예를 들어 $ \{74, 81, 96, 100 \} $을 한 숫자로 표현하려면, $74$부터 $100$까지 하나하나 시도해 보며 오류를 최소화하는 숫자를 고른다.
* 모든 구간에 대해 답을 미리 계산해 두려면 이 방법은 이론상 수행해야 하는 반복문의 수가 $n^3 \times 1000$예 비례하지만, 대부분의 경우 구간 길이는 $n$보다 짧고, 사용 가능한 종류 수는 1000보다 작기 때문에 시간 안에 나올 수도 있다.

* 복잡한 계산 과정이 귀찮다면 위와 같은 방법을 사용할 수도 있지만, 미분을 이용하면 길이가 $2$ 이상 구간 수열 $A[a \cdots b]$에 대해 오차 제곱의 합을 최소화하는 $m$을 쉽게 찾을 수 있다. 오차 제곱의 합을 다음과 같이 풀어 써보자.

    $\sum \limits_{i=a}^b (A[i] - m)^2 = (b-a+1)  \cdot  m^2-2\left( \sum \limits_{i=a}^b A[i] \right)m + \sum \limits_{i=a}^b \left( A[i]^2 \right)$

* 이 식은 $m$에 대한 $2$차식이고, $2$차항의 계수가 양수이므로 미분을 통해 최소점을 찾을 수 있다.
* $m$에 대해 미분한 뒤, $0$이 되는 점을 다음 식을 풀어서 찾을 수 있다.

    $ 2 \cdot (b-a+1)  \cdot  m-2 \sum \limits_{i=a}^b A[i] = 0 $

* 위 식의 답이 되는 $m$은 다음과 같다.

    $ m = \frac{\sum \limits_{i=a}^b A[i]} {b-a+1} $

* 즉 모든 값의 평균을 사용하면 오차를 최소화할수 있다는 사실을 알 수 있다.
* 우리는 정수만을 사용할 수 있으므로 평균에 가장 가까운 정수, 곧 반올림한 값을 사용한다.
* 주어진 구간의 평균을 계산하는 작업은 $O(n)$의 시간이 걸리지만, 17장에서 소개하는 기법인 부분 합을 이용해 다음과 같이 $O(1)$에 계산할 수도 있다.
* 우선 다음 정의에 따라 $A$의 부분 합을 계산한다.

    $pSum[k] = \sum \limits_{i=0}^k A[i]$

* 이 식을 이용하면 $A[a]$ 부터 $A[b]$까지의 합을 다음과 같이 구할 수 있다.

    $pSum[b] - pSum[a-1] = \sum \limits_{i=0}^b A[i] - \sum \limits_{i=0}^{a-1} A[i] = \sum \limits_{i=a}^b A[i]$

* (a = 0인 경우는 예외로 치자.) 이것을 $b-a+1$로 나누면 평균 $m$은 상수 시간에 구할 수 있다.
* 오차 제곱의 합은 어떻게 구할까?
* 역시 또 한 번 '무식하게 풀기'를 적용해서, 반복문을 수행하면서 가 수의 오차 제곱을 일일이 구해서 더할 수도 있다.
* 그러나 오차 제곱을 구하는 식을 다음과 같이 전개해 보자.

    $\sum \limits_{i=a}^b \left( A[i]-m \right)^2 
    \\ = \sum \limits_{i=a}^b \left( A[i]^2 - 2m \cdot A[i] +m^2 \right) 
    \\ = \sum \limits_{i=a}^b A[i]^2 -2m\sum \limits_{i=a}^b A[i] + m^2(b-a+1)$

* 마지막 식을 주목해 보자.
* 여기서 계산하는 데 오래 걸리는 부분은 $A[\ ]^2$의 부분합과 $A[\ ]$의 부분합인데, 이들은 $m$과는 관련이 없다.
* 따라서 한 번 더 부분 합을 사용해 이 식을 $O(1)$에 계산하게 할 수 있다.
* 따라서 알고리즘의 전체 시간 복잡도는 부분 문제의 수 $O(ns)$에 각 부분 문제의 답을 계산하는 데 드는 시간 $O(n)$을 곱한 $O(n^2s)$가 된다.


## 코드 8.15
```C++
const int INF = 987654321;
// A[]: 양자화해야 할 수열, 정렬한 상태
// pSum[]: A[]의 부분합을 저장한다. pSum[i]는 A[0].. A[i]의 합
// pSqSum[]: A[]제곱의 부분합을 저장한다. pSqSum[i]는 A[0]^2.. A[i]^2의 합
int n;
int A[101], pSum[101], pSqSum[101];
// A를 정렬하고 각 부분합을 계산한다
void precalc() {
    sort(A, A+n);
    pSum[0] = A[0];
    pSqSum[0] = A[0] * A[0];
    for(int i=1; i<n; ++i) {
        pSum[i] = pSum[i-1] +A[i];
        pSqSum[i] = pSqSum[i-1] + A[i] * A[i];
    }
}
// A[lo].. A[hi]구간을 하나의 숫자로 표현할 때 최소 오차 합을 계산한다.
int minError(int lo, int hi) {
    // 부분합을 이용해 A[lo]~ A[hi]까지의 합을 구한다.
    int sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo-1]);
    int sqSum = pSqSum[hi] - (lo == 0 ? 0 : pSqSum[lo-1]);
    // 평균을 반올림한 값으로 이 수들을 표현한다.
    int m = int(0.5 + (double)sum / (hi - lo + 1));
    // sum(A[i]-m)^2를 전개한 결과를 부분 합으로 표현
    int ret = sqSum - 2  * m * sum + m * m * (hi - lo + 1);
    return ret;
}
int cache[101][11];
int quantize(int from, int parts) {
    // 기저 사례: 모든 숫자를 다 양자화했을 때
    if(from == n) return 0;
    // 기저 사례: 숫자는 아직 남았는데 더 묶을 수 없을 때 아주 큰 값을 반환한다.
    if(parts == 0) return INF;
    int& ret = cache[from][parts];
    if(ret != -1) return ret;
    ret = INF;
    // 조각의 길이르 ㄹ변화시켜 가며 최소치를 찾는다.
    for(int partSize = 1; from + partSize <= n; ++partSize)
        ret = min(ret, minError(from, from + partSize - 1) + quantize(from + partSize, parts - 1));
    return ret;
}
```
* 코드 8.15는 지금껏 설명한 동적 계획법 알고리즘의 구현을 보여준다.
* 앞에서 논의한 바와 같이 두 개의 부분합 배열 $pSum[]$과 $pSqSum[]$을 이용해 $minError()$를 $O(1)$에 계산한 부분을 눈여겨보자.