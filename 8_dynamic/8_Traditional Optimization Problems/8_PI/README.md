# 8.7 문제: 원주율 외우기 (문제 ID: PI, 난이도: 하)

## 일만 자리나 외우라고?
* 이 문제의 입력의 크기를 보면, 어떤 방식이든지 완전 탐색으로는 이 문제를 해결하기란 불가능하다는 것을 본능적으로 알 수 있다. 사실 이 문제의 모든 답의 수를 계산하는 방법은 그다지 간단하지 않다.(답의 수를 세는 문제도 동적 계획법으로 풀 수 있다.)
*
## 메모이제이션의 적용
* 하지만 적절한 완전 탐색 알고리즘을 만들면 메모이제이션으로 이 문제를 해결할 수도 있다.
* 이 문제를 푸는 완전 탐색 알고리즘은 주어진 수열을 쪼개는 모든 방법을 하나씩 만들어 보며 그중 난이도의 합이 가장 작은 조합을 찾아낸다.
* 각 재귀 함수는 한 번 불릴 때마다 첫 조각의 길이를 하나하나 시도해보며 남은 수열을 재귀적으로 쪼갠다.
* 첫 조각의 길이는 3,4,5 중의 하니이므로 각 경우마다 하나씩의 부분 문제를 풀어야 한다.
* 이때 세 개의 부분 문제에 대한 최적해를 각각 구했다고 하면, 전체 문제의 최적해는 다음 세 경우 중 가장 작은 값이 된다.

    * 길이 3인 조각의 난이도 + 3글자 빼고 나머지 수열에 대한 최적해
    * 길이 4인 조각의 난이도 + 4글자 빼고 나머지 수열에 대한 최적해
    * 길이 5인 조각의 난이도 + 5글자 빼고 나머지 수열에 대한 최적해

* 나머지 수열의 최적해를 구할 때 앞의 부분의 어떤 식으로 쪼갰는지는 중요하지 않다. (최적 부분 구조가 성립한다는 말이다.)
* 따라서 부분 수열의 시작 위치 $begin$이 주어졌을 때 최소 난이도를 반환하는 함수 $memorize()$를 다음과 같이 정의할 수 있다.

    $memorize(begin) = \underset{L=3}{\overset{5}{min}}(memorize(begin+L)+classify(N_{begin, \ L}))$

* 여기서 $N_{begin, \ L}$은 $N[begin]$에서 시작하는 길이 $L$인 부분 문자열이고, $classify()$는 해당 조각의 난이도를 반환하는 함수라고 하자. 이 함수는 $begin$이 같을 때 항상 같은 값을 반환하므로, 메모이제이션으로 쉽게 최적화할 수 있다.

## 코드 8.14
```C++
const int INF = 987654321;
string N;
// N[a..b] 구간의 난이도를 반환한다.
int classify(int a, int b) {
    // 숫자 조각을 가져온다.
    string M = N.substr(a, b-a+1);
    // 첫 글자만으로 이루어진 문자열과 같으면 난이도는 1
    // string(M.size(), M[0]): M의 첫 번째 문자 M[0]로 이루어진 길이 M.size()의 문자열을 생성합니다.
    if(M == string(M.size(), M[0])) return 1;
    // 등차수열인지 검사한다.
    bool progressive = true;
    for(int i=0; i<M.size()-1; ++i)
        if(M[i+1] - M[i] != M[1] - M[0])
            progressive = false;
    // 등차수열이고 공차가 1 혹은 -1이면 난이도는 2
    if(progressive && abs(M[1] - M[0]) == 1)
        return 2;
    // 두 수가 번갈아 등장하는지 확인한다.
    bool alternating = true;
    for(int i=0; i<M.size(); ++i)
        if(M[i] != M[i%2])
            alternating = false;
    if(alternating) return 4;       // 두 수가 번갈아 등장하면 난이도는 4
    if(progressive) return 5;       // 공차가 1이 아닌 등차수열의 난이도는 5
    return 10;                      // 이 외는 모두 난이도 10
}

int cache[10002];
// 수열 N[begin..]를 외우는 방법 중 난이도의 최소 합을 출력한다.
int memorize(int begin) {
    // 기저 사례: 수열의 끝에 도달했을 경우
    if(begin == N.size()) return 0;
    // 메모이제이션
    int& ret = cache[begin];
    if(ret != -1) return ret;
    ret = INF;
    for(int L=3; L<=5; ++L)
        if(begin + L <= N.size())
            ret = min(ret, memorize(begin+L) + classify(begin, begin+L-1));
    return ret;
}
```
*  코드 8.14는 이 문제를 해결하는 동적 계획법 알고리즘을 구현한 것이다.
* 이 코드는 크게 숫자의 한 조각이 주어졌을 때 난이도를 판정하는 $classify()$와 실제 메모이제이션을 구현하는 $memorize()$로 나뉜다.
* 조각의 난이도를 파넞ㅇ하는 것은 번거롭지만 어렵거나 시간이 오래 걸리는 작업은 아니다. 따라서 효율성보다는 구현의 용이성과 간결함에 초점을 맞춰 구현하는 것이 좋다.
* 실제 최소의 난이도 조합을 구하는 함수 $memorize()$의 구현은 점화식으로부터 간단하게 얻을 수 있다.
* 이 알고리즘에는 최대 $n$개의 부분 문제가 있고, 각 부분 문제를 해결하는 데 최대 세 개의 부분 문제를 본다.
* 따라서 위의 코드의 시간 복잡도는 $O(n)$이 된다.