# 예제: 최대 증가 부분 수열 (문제 ID: LIS, 난이도: 하)

## 완전 탐색에서 시작하기
* 최대 증가 부분 수열을 찾는 문제를 숫자 하나식으로 조각낸 뒤, 한 조각에서 숫자 하나씩을 선택하는 완전 탐색 알고리즘을 만들어 보자.
* 수열 $A$를 입력받아 $LIS$의 길이를 반환하는 재귀 함수 $lis(A)$는, $A$의 모든 증가 부분 수열을 만든 뒤 그중 가장 긴 것의 길이를 반환한다.
* 한 조각마다 숫자 하나를 선택하기로 했으니 $lis(A)$는 수열의 첫 번째 수를 고르고 나머지 부분을 재귀적으로 만들 것이다.

```
```

* $lis(A)$가 수열의 첫 숫자로 $A[j]$를 골랐다고 하자. 
* $A[j]$에서 시작하는 증가 수열 중 가장 긴 증가 수열을 찾으려면 어떻게 해야할까? $A[j+1...]$ 부분 수열에서 $A[i]$보다 큰 숫자들만 고른 부분 수열 $B$를 만들고 $B$의 $LIS$를 재귀 호출로 계산한다.
* $B$에서 얻은 $LIS$를 $A[j]$ 뒤에 붙이면 $A[j]$로 시작하는 $LIS를 얻을 수 있다.
* $B$의 $LIS를 구할 때 $A[j]$나 그 이전에 선택한 숫자들은 알 필요 없다.
* 이것은 $LIS$문제에서도 __최적 부분 구조가__ 성립함을 보여준다.

### 코드 8.10
```C++
int lis(const vector<int>& A) {
    // 기저 사례: A가 텅 비어 있을 때
    if(A.empty()) return 0;
    int ret = 0;
    for(int i=0; i<A.size(); ++i) {
        vector<int> B;
        for(int j=i+1; j<A.size(); ++j)
            if(A[i] < A[j])
                B.push_back(A[j]);
        ret = max(ret, 1+lis(B));
    }
    return ret;
}
```
* 이 완전 탐색 알고리즘을 실제 구현한 것이 코드 8.10이다.

## 입력 손보기
* 이 코드는 완전 탐색의 기능은 훌륭히 수행하지만, 메모이제이션을 적용하기 까다롭다.
* 우선, __입력이 정수가 아니라 정수의 배열이기 때문이다.__ 물론 $STL$의 $map$같은 연관 배열을 써서 메모이제이션을 할 수 있지만 이것은 엄청나게 느리기 때문에 가능한 최후의 수단이다.
* $A$의 정의를 이용해 $A$를 좀더 간단하게 표현하는 방법을 생각해 보자. $A$는 항상 다음 두 가지 중 하나가 된다.
    1. 원래 주어진 수열 $S$
    2. 원래 주어진 수열의 원소 $S[i]$에 대해, $S[i+1 \cdots]$ 부분 수열에서 $S[i]$보다 큰 수들만을 포함하는 부분 수열

* 2번 정의에서 이전에 선택한 수들이 정의에 포함되지 않은 데 유념해야한다. 이전에 선택된 수들은 어차피 마지막에 선택된 수보다 전에 있고 더 작기 때문에, 이들보다 뒤에 있고 커야 한다는 조건은 2번 조건만으로 모두 만족된다.
* 이 정의에서 유념해 볼 것은 2번 정의에 포함되는 $A$는 $S$의 인덱스와 $1:1$대응된다는 점이다.
* $A$로 주어질 수 있는 입력은 전부 $N+1$가지밖에 없다는 이야기다.
* 그럼 아예 다음과 같이 부분 문제의 정의를 바꾸면 어떨까?
    
    $lis(start) = S[start]$에서 시작하는 부분 증가 수열 중 최대의 길이

* 재귀 호출할 때마다 우리는 $S[start]$보다 뒤에 있고 큰 수들 중 하나를 다음 숫자로 결정한 뒤, 여기서 시작하는 부분 증가 수열의 최대치를 구한다.

## 코드 8.11
```C++
int n;
int cache[100], S[100];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis2(int start) {
    int& ret = cache[start];
    if(ret != -1) return ret;
    // 항상 S[start]는 있기 때문에 길이는 최하 1
    ret = 1;
    for(int next = start+1; next<n; ++next)
        if(S[start] < S[next])
            ret = max(ret, lis2(next)+1);
    return ret;
}
```
* 별도의 기저 사례가 없이, 뒤에 더 이을 숫자가 없는 경우에도 for문을 순회하는 점을 눈여겨보자. 이때는 재귀 호출을 할 일이 한 번도 없기 때문에 무조건 1을 반환한다.
    * 이 부분이 무조건 모든 수열을 탐색하는 것이 문제라고 하는지 잘 모르겠다.
* 이 코드는 총 $O(n)$개의 부분 문제를 갖고, 하나를 해결할 때마다 $O(n)$시간의 반복문을 순회하므로 전체 $O(n^2)$시간 복잡도를 갖는다.

## 시작 위치 고정하기
* $lis2()$를 호출할 때는 항상 증가 부분 수열의 시작 위치를 지정해 줘야 하므로, 처음에 호출할 때 각 위치를 순회하면서 __최대 값을 찾는__ 다음과 같은 형태의 코드를 작성해야 한다.
```C++
int maxLen = 0;
for(int begin=0; begin<n; ++begin)
    maxLen = max(maxLen, lis2(begin));
```
* 이것도 귀찮게 느껴진다면 간단한 문제 변형을 통해 이 코드를 없앨 수 있다.
* $S[-1] = - \infty$라고 가정하는 코드를 작성한다.
* $lis2(-1)$을 호출하면 항상 $-\infty$부터 시작하니까 모든 시작 위치를 자동으로 시도하게 된다.

## 코드 8.12
```C++
int n;
int cache[101], S[100];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis3(int start) {
    int& ret = cache[start+1];
    if(ret != -1) return ret;
    // 항상 S[start]는 있기 때문에 길이는 최하 1
    ret = 1;
    for(int next = start+1; next<n; ++next)
        if(start == -1 || S[start]<S[next])
            ret = max(ret, lis3(next)+1);
    return ret;
}
```
* $start = -1$이 주어질 수 있기 때문에 $cache[\ ]$에 접근할 때 $cache[start]$ 대신 $cache[start+1]$을 쓰는 것을 유의해 보자.
* $cache[ \ ]$의 크기도 $1$ 커졌다. 이제 $lis3(-1)-1$을 결과로 쓰면 된다.
* $S[-1]$은 가상으로 추가한 입력 값이기 때문에 최종 반환 값에서 빼 줘야 한다.


## 더 빠른 해법
* $O(nlgn)$에 $LIS$를 찾을 수 이쓴 알고리즘이 있다.
* 이 알고리즘은 텅 빈 수열에서 시작해 숫자를 하나씩 추가해 나가며 각 길이를 갖는 증가 수열 중 가장 마지막 수가 작은 것은 무엇인지를 추적한다.
* 예를 들어 $S$의 첫 다섯 원소가 $\{5, 6, 7, 1, 2\}$라고 하자.
* 이 부분 수열의 $LIS$는 길이가 $3$인 $\{5, 6, 7 \}$ 하나밖에 없다.
* 반면 길이가 $2$인 부분 증가 수열은 $\{5,6\}, \{5,7\}, \{1,2\}$의 세 개가 있을 수 있다.
* 이 중 가장 유리한 것은 $\{1,2\}$이다. 다음 수로 $3$이나 $4$가 주어질 경우 $\{1,2\}$뒤에는 연결해서 길이 $3$인 원소를 만들 수 있는데, $\{5,6\}$ 뒤에는 연결할 수 없기 때문이다.
* 원소를 추가하는 과정에서 다음과 같은 배열을 유지합시다.

    $C[i]$ = 지금까지 만든 부분 배열이 갖는 길이 $i$인 증가 부분 수열 중 최소의 마지막 값

* 이 값을 이용하도록 코드를 개선하면 $LIS$의 길이 $k$에 대해 $O(nk)$ 시간에 $LIS$를 찾을 수 있다.
* 여기서 한발짝 더 나아가 $C[ \ ]$가 항상 순증가한다는 사실을 깨닫고 나면, $C[ \ ]$에서 이분 검색을 함으로써 $LIS$를 $O(nlgk) \le O(nlgn)$에 찾는 알고리즘을 만들 수 있다.




<div id="my_tag"></div>

# 최적화 문제 동적 계획법 레시피
* 다음은 최적화 문제의 동적 계획법을 설계하기 위한 과정을 간략하게 정리한 것이다. 물론 이 과정이 항상 모든 문제를 해결해 주는 것은 아니지만, 동적 계획법에 익숙해지기 전에 어떤 식으로 생각해야 할지에 대한 대략적인 지침은 될 것이다.

    1. 모든 답을 만들어 보고 그중 최적해의 점수를 반환하는 완전 타맥 알고리즘을 설계합니다.
    2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꿉니다. 
    3. 재귀 호출의 입력에 이전의 선택에 관련된 정보가 있다면 꼭 필요한 것만 남기고 줄입니다. 문제에 최적 부분 구조가 성립할 경우에는 이전 선택에 관련된 정보를 완전히 없앨 수도 있습니다. 여기서 우리의 목표는 가능한 한 중복되는 부분 문제를 많이 만드는 것입니다. 입력의 종류가 줄어들면 줄어들 수록 더 많은 부분 문제가 중복되고, 따라서 메모이제이션을 최대한도로 활용할 수 있지요.
    4. 입력이 배열이거나 문자열인 경우 가능하다면 적절한 변환을 통해 메모이제이션할 수 있도록 합니다.
    5. 메모이제이션을 적용합니다.

* 삼각형 위의 최대 경로 문제를 해결한 과정을 이 레시피에 맞춰서 설명해 보겠습니다.
