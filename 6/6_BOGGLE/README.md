# 예제: 보글 게임(문제 ID: BOGGLE, 난이도: 하)

## 문제의 분할

## 기저 사례의 선택
* 더 이상의 탐색 없이 간단히 답을 낼 수 있는 다음 경우들을 기저 사례로 선택한다.
```
1. 위치 (y,x)에 있는 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
2. (1번 경우에 해당되지 않을 경우) 원하는 단어가 한 글자인 경우 항상 성공
```
* 위의 두 조건 간의 순석 바뀌면 안 된다는 데 유의!!
* __간결한 코드를 작성하는 유용한 팁!!!__ 입력이 잘못되거나 범위에서 벗어난 경우도 기저 사례로 택해서 맨 처음에 처리하는 것, 그러면 함수를 호출하는 시점에서 이런 오류를 검사할 필요가 없다.

## 구현
``` C++
const int dx[8] = { -1, -1, -1,  1, 1, 1,  0, 0 };
const int dy[9] = { -1,  0,  1, -1, 0, 1, -1, 1 };
// 5x5의 보글 게임 판의 해당 위치에서 주어진 단어가 시작하는지를 반환
bool hasWord(int y, int x, const string& word) {
    // 기저 사례1: 시작 위치가 범위 밖이면 무조건 실패
    if(!inRange(y, x)) return false;
    // 기저 사례2: 첫 글자가 일치하지 않으면 실패
    if(board[y][x] != word[0]) return false;
    // 기저 사례3: 단어 길이가 1이면 성공
    if(word.size() == 1) return true;
    // 인접한 여덟 칸을 검사한다.
    for(int direction = 0; direction < 8; ++direction) {
        int nextY = y + dy[direction];
        int nextX = x + dx[direction];
        // 다음 칸이 범위 안에 있는지, 첫 글자는 일치하는지 확인할 필요가 없다.
        if(hasWord(nextY, nextX, word.substr(1)))
            return true;
    }
}
```
## 시간 복잡도 분석
* 최악의 경우는 답이 아예 존재하지 않는 경우이다.
* 마지막 글자에 도달하기 전에는 주변의 모든 칸에 대해 재귀 호출을 하게 된다.
* 각 칸에는 최대 여덟 개의 이웃이 있고, 탐색은 단어의 길이 N에 대해 N-1단계 진행된다.
* 따라서 검사하는 후보의 수는 최대 8^N-1 = O(8^N)이 되고, 이것이 이 알고리즘의 시간 복잡도가 된다.

## 완전 탐색 레시피
* 어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정은 대략 다음과 같다.
* 이 과정이 모든 문제에 항상 적용되는 것은 아니지만, 어떤 식으로 문제에 처음 접근해야 할지에 대한 대략적인 지침은 된다.
```
1. 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례합니다. 최대 크기의 입력을 가정했을 때 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있을지를 가늠합니다. 만약 시간 안에 계산할 수 없다면 31ㅜ의 다른 장에서 소개하는 설계 패러다임을 적용해야 합니다.
2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눕니다. 각 선택은 답의 후보를 만드는 과정의 한 조각이 됩니다.
3. 그중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성합니다.
4. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성 했으므로, 이것을 기저 사례로 선택해 처리합니다.
```

## 이론적 배경: 재귀 호출과 부분 문제
```
* 문제: 주어진 자연수 수열을 정렬하라.
* 문제: {16, 7, 9, 1, 31}을 정렬하라.
```
* 얼핏 보면 같은 문제라고 할 수 있지만 두 정의 사이에는 큰 차이가 있다.
* 전자는 특정한 입력을 지정하지 않은 반면, 후자는 특정한 입력을 지정하기 때문이다.
* 재귀 호출을 논의할 때 '문제'란 항상 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 의미한다.

