# 문제: 게임판 덮기 (문제 ID: BOARDCOVER, 난이도: 하)
* 게임판을 덮을 수 있는 모든 경우를 생성하는 완전 탐색을 이용해 해결할 수 있다.
* 흰 칸의 수가 3의 배수가 아닌 경우 무조건 답이 없으니 이 부분을 따로 처리한다.
* 흰 칸의 수를 3으로 나눠서 내려놓을 블록의 수 N을 얻은 뒤, 문제의 답을 생성하는 과정을 N조각으로 나눠 한 조각에서 한 블록을 내려놓는다.

## 중복으로 세는 문제
* 블록을 놓는 순서는 이 문제에서 중요하지 않은데, 위의 방법에서는 같은 배치도 블록을 놓는 순서에 따라서 여러 번 세는 문제가 발생한다.
* 따라서 특정한 순서대로 답을 생성하도록 강제할 필요가 있다.

## 코드 6.6
```C++
const int coverType[4][3][2] = {
    { { 0, 0 }, { 1, 0 }, { 0, 1 } },
    { { 0, 0 }, { 0, 1 }, { 1, 1 } },
    { { 0, 0 }, { 1, 0 }, { 1, 1 } },
    { { 0, 0 }, { 1, 0 }, { 1, -1 } }
};
// board의 (y,x)를 type번 방법으로 덮거나, 덮었던 블록을 없앤다.
// delta = 1이면 덮고, -1이면 덮었던 블록을 없앤다.
// 만약 블록이 제대로 덮이지 않은 경우 (게임판 밖으로 나가거나,
// 겹치거나, 검은 칸을 덮을 때) false를 반환한다.
bool set(vector<vector<int> >& board, int y, int x, int type, int delta) {
    bool ok = true;
    for(int i=0; i<3; ++i) {
        const int ny = y + coverType[type][i][0];
        const int nx = x + coverType[type][i][1];
        if(ny < 0 || ny >= board.size() || nx < 0 || nx >= board[0].size())
            ok = false;
        // board를 덮는데 이미 덮여있으면 false를 반환한다.
        else if((board[ny][nx] += delta) > 1)
            ok = false;
    }
    return ok;
}

int cover(vector<vector<int> >& board) {
    // 아직 채우지 못한 칸 중 가장 윗줄 왼쪽에 있는 칸을 찾는다.
    int y = -1, x = -1;
    for(int i = 0; i < board.size(); ++i) {
        for(int j = 0; j < board[i].size(); ++j)
            if(board[i][j] == 0) {
                y = i;
                x = j;
                break;
            }
        // y가 -1이 아니면 아직 채우지 못한 칸이 남아있다.
        if(y != -1) break;
    }
    
    // 기저 사례: 모든 칸을 채웠으면 1을 반환한다
    if(y == -1) return 1;
    int ret = 0;
    for(int type = 0; type < 4; ++ type) {
        // 만약 board[y][x]를 type 형태로 덮을 수 있으면 재귀 호출한다.
        if(set(board, y, x, type, 1))
            ret += cover(board);
        // 덮었던 블록을 치운다.
        set(board, y, x, type, -1);
    }
    return ret;
}
```

### 구현
* 한 칸을 덮는 네 가지 방법을 각각의 코드로 구현하는 것이 아니라 coverType[] 배열에 저장했습니다. 이 배열은 네 가지 방법에서 새로 채워질 칸들의 상대 좌표 ($ \Delta y, \Delta x$ )의 목록을 저장합니다.
* $set()$은 $delta$에 따라 블록을 놓는 역할과 치우는 역할을 같이 할 수 있습니다. 블록을 놓는 것과 치우는 것을 별도로 짤 필요가 없어진다.
* $set()$은 해당 위치에 블록을 놓을 수 있는지 여부도 같이 판단합니다. 단 이때 곧장 함수를 종료하는 것이 아니라 마지막까지 함수를 실행한다는 데 유의할 필요가 있습니다. 만약 블록을 구성하는 세 칸 중에 한 칸에 표시를 한 뒤 두 번째 칸에 이미 블록이 놓여 있다는 것을 발견했다고 합니다. 이때 함수를 곧장 종료하면 나중에 덮었던 블록을 치울 때, 두 번째 칸에 이미 있던 블록마저 치워 버리게 됩니다. 따라서 $set()$은 그 자리에 그냥 1을 더함으로써 이 칸에는 두 개의 블록이 겹쳐서 놓여 있다고 표시합니다.